"""
____________________________________________________________________________________________________________________
Chapter006.튜플과 세트
____________________________________________________________________________________________________________________
"""

# 튜플 속성 _____________________________________________________________________________________________________

# 001. 튜플 속성
"""
     튜플은 '()'로 선언한다.
     튜플은 리스트와 다르게 값을 수정할 수 없다. | 읽기 전용 자료형

     튜플은 리스트와 똑같이 값이 중복 될 수 있다.
     튜플은 리스트와 똑같이 여러 자료형을 입력할 수 있다.
     튜플은 리스트와 똑같이 순서가 보장된다.
"""

# 리스트와 마찬가지로 튜플은 비어있는 상태로 선언이 가능하다.
tupleValue = ()
print(tupleValue)



tupleValue = (None, 1, 2.2, True, 'c', "cake", 1 + 2j)

# Error | 튜플은 값을 수정할 수 없기 때문에 에러가 발생한다.
# tupleValue[0] = True


# 원하는 위치의 값을 접근해 사용할 수 있다.
print(tupleValue[2])


# 슬라이싱을 이용해 값을 사용할 수 있다.
print(tupleValue[0:2])


# 마찬가지로 포함여부를 'in' 키워드로 알아낼 수 있다.
print('cake' in tupleValue)


# 인덱서를 가지고 있는 자료형이기 때문에 'len()'함수를 이용하여 길이를 알아낼 수 있다.
print(len(tupleValue))







# 튜플 사용법 _____________________________________________________________________________________________________

# 001. 패킹
tupleValue = (None, 1, 2.2, True, 'c', "cake", 1 + 2j)



# 002. 언패킹
# 각자의 개별 변수에 튜플의 값을 언팩킹하여 대입시켜준다.
(a, b, c, d, e, f, g) = tupleValue
print(f"{a}, {b}, {c}, {d}, {e}, {f}, {g}")



numbers = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
# Error | 변수의 수와 값들의 수가 다르기 때문에 에러가 발생한다.
# (one, two, others) = numbers

# 그래서 나머지를 할당할 공간은 '*'을 이용한다.
(one, two, *others) = numbers
print(one) # 1
print(two) # 2

# 여기서 중요한 점은 '*'을 이용하여 여러개의 값을 할당할 경우 리스트로 값이 만들어진다.
print(others) # [3, 4, 5, 6, 7, 8, 9, 10]



# 활용 001 | others가 처음에 있을 경우
(*others, nine, ten) = numbers
print(others) # [1, 2, 3, 4, 5, 6, 7, 8]
print(nine) # 9
print(ten) # 10



# 활용 002 | others가 가운데 있을 경우
(one, *others, ten) = numbers
print(one) # 1
print(others) # [2, 3, 4, 5, 6, 7, 8, 9]
print(ten) # 10







# 튜플 함수 _____________________________________________________________________________________________________

# 001. count() | 어떤 값이 몇개 있는지 int형으로 return
tupleValue = ('a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd')
print(tupleValue.count('a')) # 튜플 안에 'a'값은 1개
print(tupleValue.count('b')) # 튜플 안에 'b'값은 2개
print(tupleValue.count('c')) # 튜플 안에 'c'값은 3개
print(tupleValue.count('d')) # 튜플 안에 'd'값은 4개

print(tupleValue.count('z')) # 튜플 안에 'z'값은 없기 때문에 0개




# 002. index() | 어떤 값이 어디에 있는지 int형으로 return
tupleValue = (None, 1, 2.2, True, 'c', "cake", 1 + 2j)
print(tupleValue.index('c')) # 'c'값은 튜플에서 4번째 인덱스에 있기 때문에 정수 4를 반환







# 세트 속성 _____________________________________________________________________________________________________

# 001. 세트 속성
"""
     세트는 '{}'로 선언한다.

     세트는 기존 인덱서 자료형들과 마찬가지로 여러개의 데이터를 저장할 수 있다.
     하지만 차이점으로는 값들의 순서가 보장되지 않으며 중복을 허용하지 않는 특성을 가지고 있다.
     
     튜플은 읽기전용이라 수정이 불가능하다 하지만 세트는 수정이 가능하다.
     수정이 가능하지만 'set[0]'과 같이 직접적으로 값에 접근할 수 없다.
     따라서 함수를 이용하여 값을 수정해야 한다.
"""
# 비어있는 세트 선언하는 방법
# {}로 비어있는 세트를 초기화하면 되지 않을까라고 생각할 수 있지만 이렇게하면 비어있는 dict(딕셔너리)자료형이 된다.
setValue = {}
print(type(setValue))

# 따라서 비어있는 세트를 만들어주려면 생성자를 이용해야 한다.
"""
      set()는 함수가 아니라 set class의 생성자이다. 
      세트는 다른 컬렉션들과 다르게 비어있는 상태로 시작하려면 생성자로 생성을 해주어야한다.
"""
setValue = set()
print(setValue) # set()


# 생성자는 나중에 class와 함께 배우게 되겠지만 set의 생성자의 경우 다른 콜렉션 자료형으로도 초기화 가능하다.
# 생성자 안에 string > set로 생성됨
setValue = set("cake")
print(setValue)

# 생성자 안에 list > set로 생성됨
setValue = set([None, 1, 2.2, True, 'c', "cake", 1 + 2j])
print(setValue)

# 생성자 안에 tuple > set로 생성됨
setValue = set((None, 1, 2.2, True, 'c', "cake", 1 + 2j))
print(setValue)

# 생성자 안에 range > set로 생성됨
setValue = set(range(10))
print(setValue)




# 속성 001 | 순서보장이 되지 않음
setValue = {"제육볶음", "순대국밥", "보쌈"}
print(setValue) # 순서가 보장되지않기 때문에 실행할 때마다 순서가 바뀐다.


# 속성 002 | 중복된 값은 허용되지 않음
setValue = {"제육볶음", "순대국밥", "보쌈", "보쌈"}
print(setValue) # 중복된 값은 허용되지 않기 때문에 고유한 값으로 저장된다.


# 속성 003 | 인덱스로 직접적으로 접근 불가능
# Error | 순서가 보장되지 않기 때문에 인덱스로 접근할 수 없다.
# print(set[0])







# 세트 함수 _____________________________________________________________________________________________________
set1 = {"돈까스", "순대국밥", "보쌈"}
set2 = {"초밥", "라멘", "돈까스"}

"""
      001. 세트의 집합 함수들
"""
# 001. union() | 합집합
print(set1.union(set2))


# 002. intersection() | 교집합
print(set1.intersection(set2))


# 003. difference() | 차집합
print(set1.difference(set2))
print(set2.difference(set1))


# 004. symmetric_difference() | 대칭 차집합
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
c = a.symmetric_difference(b)
print(c) # {1, 2, 5, 6}


# 005. issubset() | 부분집합
a = {1, 2, 3}
b = {1, 2, 3, 4, 5}
print(a.issubset(b)) # a는 b의 부분집합이니까 True
print(b.issubset(a)) # b는 a의 부분집합이 아니니까 False


# 006. issuperset() | 세트가 다른 세트에 포함되는지 확인하여 boolean형으로 return | issubset()의 피연산자 반대 개념
a = {1, 2, 3, 4, 5}
b = {1, 2, 3}
print(a.issuperset(b)) # b가 a에 포함되니까 True
print(b.issuperset(a)) # a가 b에 포함되지 않으니까 False


# 007. isdisjoint() | 세트끼리 공통 요소가 있는지 boolean으로 return
"""
      001. issubset(), issuperset()함수와는 다르게 피연산자 구분이 없다.
      002. 공통요소가 없으면 True를 반환하고 있으면 False를 반환한다.
"""
a = {1, 2, 3}
b = {1, 2, 3, 4, 5}
# 피연산자 구분없이 서로 공통 요소가 있기 때문에 False를 return
print(a.isdisjoint(b))
print(b.isdisjoint(a))



"""
      002. 세트의 값을 수정할 수 있는 함수들
"""
# 008. add() | 요소 추가
fruits = {'apple', 'banana', 'orange'}
fruits.add('mango')
print(fruits) # {'orange', 'apple', 'mango', 'banana'}




# 009. discard() | 지정한 값의 요소를 삭제 | 에러가 발생하지 않음
a = {1, 2, 3}
a.discard(2)
print(a) # {1, 3}
a.discard(5) # 존재하지 않는 값을 삭제해도 에러가 발생하지 않는다.
print(a) # {1, 3}




# 010. remove() | 지정한 값의 요소를 삭제 | 에러가 발생함
a = {1, 2, 3}
a.remove(2)
print(a) # {1, 3}
# Error | discard()와 다르게 존재하지 않는 값을 삭제하려고 하면 에러가 발생한다.
# a.remove(5)




# 011. pop() | 꺼내다 | 값을 사용하고 세트에서는 삭제됨
# 랜덤으로 값을 pop한다.
a = {'ㄱ', 'ㄴ', 'ㄷ'}
print(a.pop()) # 1
print(a) # {2, 3}

# 하지만 값의 크기가 있을 경우 항상 최소값을 pop한다.
a = {1, 2, 3}
print(a.pop()) # 1
print(a) # {2, 3}

a = set()
# print(a.pop()) # Error | 비어있는 세트를 pop하려고 하면 에러가 발생한다.




# 012. clear() | 세트의 모든 요소를 제거
a = {1, 2, 3}
a.clear()
print(a) # set()
"""
      세트에서 clear()함수를 쓰면 값이 비어있는 세트가 되지만
      del 키워드를 사용하면 세트가 아예 존재하지 않게 된다. | 변수를 아예 사용할 수 없다.
      ________________________________________________________________________________
      del키워드는 아예 존재 자체를 없애버리는 것이기 때문에
      인덱스를 이용하여 요소 접근이 불가능한 set(세트)에서는 헷갈릴 수 있어서 부가설명함.
"""
a = {1, 2, 3}
del a
# Error | 세트가 아예 제거되었기 때문에 더이상 사용할 수 없다.
# print(a) # 아예 정의조차 되지않았다고 에러로그가 뜸 | NameError: name 'a' is not defined




# 013. copy() | 깊은 복사
# 세트의 얕은 복사
setA = set()
setB = setA
setB.add(1)
print(setB) # {1}
print(setA) # {1}

# 마찬가지로 깊은 복사를 하려면 copy()함수를 이용하면 된다.
setA = set()
setB = setA.copy()
setB.add(1)
print(setB)
print(setA)



"""
      003. 갱신 함수들
      ___________________________________________________________________
      여기서부터 주의할 점은 update함수들은 피연산자의 값이 갱신된다는 점이다.
      이전까지 나왔던 함수들은 세트의 값이 갱신되지 않으며 값만 도출된다.
"""
# 014. update() | 갱신 | 세트에 다른 세트의 요소들을 추가하여 갱신
a = {1, 2}
b = {3, 4, 5}
a.update(b) # 세트 a에 b세트의 요소들을 추가한다.
print(a) # {1, 2, 3, 4, 5} | a만 갱신
print(b) # {3, 4, 5}




# 015. intersection_update() | 세트를 다른 세트와 교집합으로 갱신
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
a.intersection_update(b)
print(a) # {3, 4} | a만 갱신
print(b) # {3, 4, 5, 6}




# 016. difference_update() | 세트를 다른 세트와 차집합으로 갱신
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
a.difference_update(b)
print(a) # {1, 2} | a만 갱신
print(b) # {3, 4, 5, 6}




# 017. symmetric_difference_update() | 세트를 다른 세트와 대칭차집합으로 갱신
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
a.symmetric_difference_update(b)
print(a) # {1, 2, 5, 6} # a만 갱신
print(b) # {3, 4, 5, 6}



"""
      len()함수
"""
# 018. len() | set의 내장함수가 아님 | 세트의 길이를 int형으로 return
setValue = {1, 2, 3, 4, 5}
print(len(setValue))



"""
      001. 기본 집합 연산자들
      __________________________________________________________
      집합 연산       메소드                              연산자
      합집합          union()                             |
      교집합          intersection()                      &
      차집합          difference()                        -
      대칭 차집합     symmetric_difference()              ^
"""

"""
      002. 갱신(update) 집합 연산자들
      __________________________________________________________
      집합 연산       메소드                              연산자
      합집합          update()                            |=
      교집합          intersection_update()               &=
      차집합          difference_update()                 -=
      대칭 차집합     symmetric_difference_update()       ^=
"""

"""
      003. 집합관계 연산자들
      __________________________________________________________
      집합 관계       메소드                              연산자
      부분집합        issubset()                          <=
      상위집합        issuperset()                        >=
      진부분집합      없음                                 <
      진상위집합      없음                                 >
      __________________________________________________________
      <일반 집합>과 <진 집합>의 차이
      예를들어 A={1,2}라 하면
      "부분집합"은 {},{1},{2},{1,2}이지만
      "진부분집합"은 {},{1},{2} 입니다.
      따라서 <진 집합>은 자기자신을 제외한다.
"""

"""
      frozenset
      _____________________________________________________________________________________________________________
      파이썬에는 수정이 가능한 set와 달리 수정이 불가능한 set인 frozenset이라는 것이 존재한다.
      set과 달리 add(), clear(), discard(), pop(), remove(), update()함수들이 존재하지 않기 때문에 값을 수정할 수 없다.
      _____________________________________________________________________________________________________________
      뜻 | frozen(언, 얼었다)set
"""

"""
      알아두면 좋은 용어들
      _________________________________________________________________________________________________________________
      컬렉션(Collection)
           여러개의 값을 가질 수 있는 타입형을 컬렉션 타입(Collection type)이라고 부른다.
           string, list, tuple, set, dict 등등
      _________________________________________________________________________________________________________________
      시퀀스(Sequence)
           string, list, tuple 등등 순서가 있어서 인덱싱이 가능한 자료형들울 시퀀스 타입(Sequence type)이라고 부른다.
      _________________________________________________________________________________________________________________


      

      파이썬 자료형들의 구조와 용어들
      _________________________________________________________________________________________________________________
      Numeric Types      int(정수), float(소수), complex(복소수)
      Sequence Types     str(문자열), list(리스트), tuple(튜플)
      Mapping Type       dict(딕셔너리)
      Set Types          set(집합)
      Boolean Type       bool(불리언)
      Binary Types       bytes, bytearray, memoryview

      Sequence, Mapping, Set는 Collection이다.
      나머지는 값을 하나만 할당할 수 있는 타입형이다.
      따라서 Set는 순서가 보장되지 않기 때문에 Sequence가 아니다.
"""

"""
     Notice.
     _____________________________________________________________________________________________

     오늘 수업의 과제는 메소드를 대신하는 연산자를 이용하여 세트(set) 연산해보기.
     frozenset를 따로 공부해서 연구해보기 | 예를들어 set와 frozenset와 연산이 가능한지 등등
     _____________________________________________________________________________________________
"""